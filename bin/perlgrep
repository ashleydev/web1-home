#!/usr/bin/perl

# i wrote this on a day with nothing to do, and it was mostly a test of what i can do in perl.  it is used for quick manipulation of text files
# instead of running 10 grep commands in a shell and saving 10 tmp files

use String::Strip;
use Term::ANSIColor qw(:constants);

use strict;
use Switch;

use constant DEBUG => 0;

my $file_on_load = shift(@ARGV);

my %hash;
my $hash_position = 0;

sub parseRegexAndPrint {
  
  my $command_line_in = shift;

  my @buffer = @{$hash{$hash_position}};
  my @buffer_new;

  my $flag_mutate;
  my $flag_copy = 0;

  my $flag_mode;

# not going to bother with this check for now, maybe when it comes up to be a problem
#  my $phony_regex_ending = q[\\\/(i|ig|gi|g)?]; # this means that the ending that looks like /i is actually \/i, which is not a true perl regex end

  StripLTSpace($command_line_in);


  ## COMMAND PARSER
  if (length($command_line_in)) {

    if ($command_line_in =~ m/^copy (\d+) (\d+)$/) { if ($hash{$1}) { my @copy = @{$hash{$1}}; $hash{$2} = \@copy; } }
    elsif ($command_line_in =~ m/^(set|s) ?(\d+)$/) { unless ($hash{$2}) { my @new; $hash{$2} = \@new; } $hash_position = $2; }
    elsif ($command_line_in =~ m/^w\s+(\S+)?$/) {
      my $write_filename;

      if (defined($1)) {
	$write_filename = $1;
      } else {
	$write_filename = $file_on_load;
      }

      if (open(WRITE, ">$write_filename")) {
	my $buffer_write;
	foreach (@{$hash{$hash_position}}) {
	  $buffer_write .= $_;
	}

	print WRITE $buffer_write;

	print "Saved to $write_filename: OK\n";
	close(WRITE);

      } else {
	print "ERROR:  Failed to open $write_filename for writing!\n";
      }

    }

    elsif ($command_line_in =~ m/^\?$/) { print (join(" ", (sort {$a <=> $b} (keys(%hash))))."\n"); }
    elsif ($command_line_in =~ m/^(quit|q|exit)$/) { exit(0); }
    else {

      if ($command_line_in =~ m/^(\.=|!)/) {
	print "___mutate array flag set\n" if DEBUG;
	$flag_mutate = 1;
	$command_line_in =~ s/^$&//;
      } elsif ($command_line_in =~ m/^=/) {
	print "___copy array flag set\n" if DEBUG;
	$flag_copy = 1;
	$command_line_in =~ s/^$&//;
      }

      if ($command_line_in =~ m/^\//) {
	$flag_mode = 'm';
	$command_line_in = 'm'.$command_line_in;
      } elsif ($command_line_in !~ m/^(s|m|M)\//) {
	$flag_mode = 'm';
	$command_line_in = 'm/'.$command_line_in;
      } 
      
      if ($command_line_in =~ m/M\//) {
	$flag_mode = 'M';
	$command_line_in =~ s/^M/m/;
      } 

      if ($command_line_in !~ m/\/[gi]*$/) {
	$command_line_in = $command_line_in.'/';
      }

      print "___ REGEX:  [$command_line_in]\n" if DEBUG;

      foreach (@buffer) {

	if ($flag_mode eq 'm') {
	  eval('if ($_ =~ '.$command_line_in.') { push(@buffer_new, $_); } ');
	} elsif ($flag_mode eq 'M') {
	  eval('if ($_ !~ '.$command_line_in.') { push(@buffer_new, $_); } ');
	} else {
	  eval('$_ =~ '.$command_line_in.';');
	  push(@buffer_new, $_);
	}
      }

      print @buffer_new;

      if ($flag_mutate) {
	$hash{$hash_position} = \@buffer_new;
      } elsif ($flag_copy) {
	my @array = sort(keys(%hash));
#        print "___array keys: @array\n" if DEBUG;
	$hash_position = pop(@array)+1;
	$hash{$hash_position} = \@buffer_new;
      }
    } # end of major case
  } # end of if(length)

  #####################

} # end of parseRegexAndPrint

if ( -f $file_on_load ) {

  #### READ file_on_load CONTENTS
  my @buffer;

  open (READ, $file_on_load);
  @buffer = <READ>;

  $hash{$hash_position} = \@buffer;
  #######################


  my $answer;
  do {
    print BOLD, YELLOW, "Perl regex [$hash_position]: ", RESET;
    $answer = <STDIN>; chomp($answer);

    unless (length($answer)) {
      $answer = '.';
    } 

    parseRegexAndPrint($answer);

  } while ($answer);

  my $answer;

  #print Dumper @buffer;
}
